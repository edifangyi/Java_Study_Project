<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0041)http://bruce-peng.javaeye.com/blog/198149 -->
<HTML dir=ltr xml:lang="zh-CN" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>java 试题-- 为找工作作准备,呵呵！ - bruce.peng - JavaEye技术网站</TITLE>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<META 
content="网上找的－－－呵呵 一、Java基础知识 1.Java有那些基本数据类型，String是不是基本数据类型，他们有何区别。 2.字符串的操作： &nbsp; 写一个方法，实现字符串的反转，如：输入abc，输出cba &nbsp; 写一个方法，实现字符串的替换，如：输入bbbwlirbbb，输出bbbhhtccc。 3.数据类型之间的转换 &nbsp; 如何将数值型字符转换为数字（Integer，Do ..." 
name=description>
<META content="  java 试题-- 为找工作作准备,呵呵！" name=keywords><LINK 
href="/images/favicon.ico" type=image/x-icon rel="shortcut icon"><LINK 
title=bruce.peng href="/rss" type=application/rss+xml rel=alternate><LINK 
media=screen 
href="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/blog.css" 
type=text/css rel=stylesheet><LINK media=screen 
href="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/blue.css" 
type=text/css rel=stylesheet>
<SCRIPT 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/application.js" 
type=text/javascript></SCRIPT>
<LINK media=screen 
href="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/SyntaxHighlighter.css" 
type=text/css rel=stylesheet>
<SCRIPT 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/shCoreCommon.js" 
type=text/javascript></SCRIPT>

<SCRIPT 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/se_hilite.js" 
type=text/javascript></SCRIPT>

<STYLE>DIV#main {
	BORDER-TOP-WIDTH: 0px; PADDING-RIGHT: 0px; PADDING-LEFT: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; PADDING-BOTTOM: 0px; WIDTH: 740px; PADDING-TOP: 0px; BACKGROUND-COLOR: transparent; BORDER-RIGHT-WIDTH: 0px
}
</STYLE>
<LINK media=screen 
href="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/ui.css" 
type=text/css rel=stylesheet>
<SCRIPT src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/compress.js" 
type=text/javascript></SCRIPT>

<META content="MSHTML 6.00.2900.2604" name=GENERATOR></HEAD>
<BODY>
<DIV id=header>
<DIV id=site_logo><A href="http://www.javaeye.com/blogs"><IMG 
title=JavaEye-最棒的软件开发交流社区 alt=JavaEye3.0 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/logo_small.gif"></A></DIV>
<UL id=user_nav>
  <LI class=last><A href="http://bruce-peng.javaeye.com/index/help">帮助</A> </LI>
  <LI><A href="http://bruce-peng.javaeye.com/signup">注册</A> </LI>
  <LI><A href="http://bruce-peng.javaeye.com/login">登录</A> </LI>
  <LI class=highlight><SPAN>您还没有登录 !</SPAN> </LI></UL></DIV>
<DIV id=page>
<DIV class=clearfix id=branding>
<DIV id=blog_name>
<H1><A href="http://bruce-peng.javaeye.com/">bruce.peng</A></H1></DIV>
<DIV id=blog_preview></DIV>
<DIV id=blog_domain>永久域名 <A 
href="http://bruce-peng.javaeye.com/">http://bruce-peng.javaeye.com/</A></DIV></DIV>
<DIV class=clearfix id=content>
<DIV id=main>
<DIV class=blog_main>
<DIV id=blog_nav>
<DIV id=pre_next><A class=next 
href="http://bruce-peng.javaeye.com/blog/198991">spring需要的一些jar包</A> | <A 
class=pre href="http://bruce-peng.javaeye.com/blog/197351">设计模式 －原型模式</A> 
</DIV></DIV>
<DIV class=blog_title>
<DIV class=date><SPAN class=year>2008</SPAN><SPAN class=sep_year>-</SPAN><SPAN 
class=month>05</SPAN><SPAN class=sep_month>-</SPAN><SPAN 
class=day>29</SPAN></DIV>
<H3 class="" title=""><A href="http://bruce-peng.javaeye.com/blog/198149">java 
试题-- 为找工作作准备,呵呵！</A></H3></DIV>
<DIV class=blog_content>网上找的－－－呵呵 <BR>一、Java基础知识 
<BR>1.Java有那些基本数据类型，String是不是基本数据类型，他们有何区别。 <BR>2.字符串的操作： <BR>&nbsp; 
写一个方法，实现字符串的反转，如：输入abc，输出cba <BR>&nbsp; 
写一个方法，实现字符串的替换，如：输入bbbwlirbbb，输出bbbhhtccc。 <BR>3.数据类型之间的转换 <BR>&nbsp; 
如何将数值型字符转换为数字（Integer，Double） <BR>&nbsp; 如何将数字转换为字符 <BR>&nbsp; 如何取小数点前两位，并四舍五入。 
<BR>4.日期和时间 <BR>&nbsp; 如何取得年月日，小时分秒 <BR>&nbsp; 如何取得从1970年到现在的毫秒数 <BR>&nbsp; 
如何获取某个日期是当月的最后一天 <BR>&nbsp; 如何格式化日期 <BR>5.数组和集合 <BR>6.文件和目录（I/O）操作 <BR>&nbsp; 
如何列出某个目录下的所有文件 <BR>&nbsp; 如何列出某个目录下的所有子目录 <BR>&nbsp; 判断一个文件或目录是否存在 <BR>&nbsp; 
如何读写文件 <BR>7.Java多态的实现（继承、重载、覆盖） 
<BR>8.编码转换，怎样实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串。 
<BR>9.Java中访问数据库的步骤，Statement和PreparedStatement之间的区别。 
<BR>10.找出下列代码可能存在的错误，并说明原因： <BR>二、JSP&amp;Servlet技术 
<BR>1.描述JSP和Servlet的区别、共同点、各自应用的范围 
<BR>2.在Web开发中需要处理HTML标记时，应做什么样的处理，要筛选那些字符（&lt; &gt; &amp; “”） 
<BR>3.在JSP中如何读取客户端的请求，如何访问CGI变量，如何确定某个Jsp文件的真实路径。 
<BR>4.描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。 <BR>5.列出Jsp中包含外部文件的方式，两者有何区别。 
<BR>6.说明Jsp中errorPage的作用，应用范围。 <BR>7.介绍在Jsp中如何使用JavaBeans。 <BR>8.简单介绍JSP的标记库 
<BR>9.Jsp和Servlet中的请求转发分别如何实现。 <BR>三、J2EE相关知识 <BR>1.介绍J2EE、J2SE、J2SE的区别。 
<BR>2.J2EE是一种技术还是一种平台，他提供了那些技术。 <BR>3.什么是Application Server，它有什么功能和优点。 
<BR>4.简单介绍连接池的优点和原理。 <BR>5.Web.xml的作用 <BR>四、其他 
<BR>1.Web安全性的考虑（表单验证、浏览器Basic方式的验证，应用程序的安全性，SSL，代码考虑） <BR>2.简单介绍您所了解的MVC。 
<BR>3.简单介绍所了解的XML。 <BR>4.文档和编码规范 <BR>5.Java中的分页、效率考虑。 <BR>6.简单介绍您所了解的structs。 
<BR>________________________________________ <BR>1.xml在项目中的作用 <BR>2.s-EJB 与 
e-EJB的区别 <BR>3.会话面的作用 <BR>4.cmp与bmp的优缺点 <BR>5.j2me程序的必需的几个部分 <BR>6.c/s与b/s的区别 
<BR>7.构建一个connect pool,然后再调用它， <BR>8.j2ee平台与dotnet平台的区别 <BR>9.ejb的life cycle 
<BR>10.session bean 和 entity bean的区别 <BR>11.ejb中的transaction机制 
<BR>12.synchronized (生产者和消费） <BR>13.String 和 StringBuffer <BR>14.Serializable 
<BR>15.MVC （Struts的工作流程） <BR>16.什么是MDA <BR>17.tcp与udp的区别 <BR>18.链表与散列表和数组的区别 
<BR>19.堆和栈的区别 <BR>20.ejb的分类及区别 <BR>21.你对现在软件业以及国内软件业的看法 <BR>22.谈谈java多线程 
<BR>23.谈谈文件加密技术 <BR>24.软件开发生命周期 <BR>25.路由协议种类及特点 
<BR>26.java的awt和swing组件的GUI设计的关键 <BR>27.对于java流的认识 <BR>28.简单描述一下awt与swing区别。 
<BR>29.简述java编程中事件处理模式。 <BR>30.你编写过applet吗？applet的安全权限如何？试列举java 
application或者applet中与servlet/jsp通信可以采用的方式。 
<BR>31.简述逻辑操作(如&amp;,|)与条件操作(如&amp;&amp;,||)的区别。 <BR>32.简述 Java Server Page 和 
Servlet 的联系和区别。 <BR>33.简述synchronized和java.util.concurrent.locks.Lock的异同 ？ 
<BR>34.EJB规范规定EJB中禁止的操作有哪些？ <BR>35.java除了8种基本类型外，在虚拟机里还有哪一种，有什么作用? 
<BR>36.除了使用new关键字创建对象意外，试列举另外三种以上创建实例的方式? 
<BR>37.classloader中，JDK的API、Classpath中的同web-inf中的class加载方式有什么区别？ 
<BR>38.列举三种以上垃圾回收算法，并比较其优缺点？ <BR>39.编写代码实现一个线程池 <BR>40.描述一下JVM加载class文件的原理机制? 
<BR>41.试举例说明一个典型的垃圾回收算法？ <BR>42.请用java写二叉树算法，实现添加数据形成二叉树功能，并以先序的方式打印出来. 
<BR>43.请写一个java程序实现线程连接池功能？ <BR>44.给定一个C语言函数，要求实现在java类中进行调用。 <BR>45.如何获得数组的长度？ 
<BR>46.访问修饰符“public/private/protected/缺省的修饰符”的使用 
<BR>47.用关键字final修饰一个类或者方法时，有何意义？ <BR>48.掌握类和对象的概念，掌握面向对象编程的本质 
<BR>49.静态变量和静态方法的意义，如何引用一个类的静态变量或者静态方法？ 
<BR>50.JAVA语言如何进行异常处理，关键字：thorws,throw,try,catch,finally 
<BR>51.Object类(或者其子类)的finalize()方法在什么情况下被调用？ 
<BR>52.一个“.java”原文件中是否可以包括多个类（不是内部类）？ <BR>53.掌握内部类和接口的概念 
<BR>54.StringTokenizer类的使用 <BR>55.数据结构，如何遍历List中的元素？ <BR>&nbsp;&nbsp; 
如果要按照键值保存或者访问数据，使用什么数据结构？ <BR>&nbsp;&nbsp; 要掌握Collection相关的接口和类的使用 
<BR>56.使用StringBuffer类与String类进行字符串连接时有何区别？ <BR>57.调用Thread类的destroy()方法有什么后果？ 
<BR>58.多线程，用什么关键字修饰同步方法？stop()和suspend()方法为何不推荐使用？ 
<BR>59.使用socket建立客户端与服务器的通信的过程 <BR>60.JAVA语言国际化应用，Locale类，Unicode 
<BR>61.描述反射机制的作用 <BR>62.如何读写一个文件？ <BR>63.在图形界面中，一个按钮如何处理鼠标点击事件？ 
<BR>64.在图形界面中，一个表格，如何实现编辑单元格时弹出下拉框？ <BR>65.如何加载图片？ <BR>66.什么是模态对话框？ 
<BR>67.阐述MVC的概念 <BR>68.GUI布局管理器的使用，FlowLayout,BorderLayout,GridBagLayout 
<BR>69.如何构造一棵树？选择树的一个节点时，如何得到这个节点？ <BR>70.向编辑框中输入字符时，如何控制只输入整数？ 
<BR>71.描述使用JDBC连接数据库的过程 <BR>72.EJB分为几类？什么是BMP,CMP? <BR>73.什么是JNDI? 
<BR>74.ADO是什么?ActiveX数据对象,是一个应用级程序接口. <BR>75.四种JDBC方式?目前的版本? 
<BR>76.EJB有哪几种?区别是什么? <BR>77.JavaBean与EJB有什么区别? <BR>78.软件开发生命周期有哪几个阶段? 
<BR>79.软件开发有哪些因素? <BR>80.软件开发中如何进行版本控制? <BR>81.UML中,类视图如何表示类中的继承与聚合? 
<BR>82.客户端游标与服务器端游标的区别? <BR>83.动态游标与静态游标的区别? <BR>84.dotnet由哪几个基本框架组成? 
<BR>85.Oracle中SGA是什么? <BR>86.web servers是什么? <BR>87.UNIX中QT是什么意思? 
<BR>88.在软件开发生命周期中的哪个阶段开始测试? <BR>89.dotnet与J2EE的比较? <BR>90.什么是ActiveX? 
<BR>91.Java中IDL是什么? 
<BR>92.ISO9000和CMM是什么?IS09000和CMM(软件能力成熟度模型)认证是国际上通用的软件质量评估方法.CMM的五个成熟度等级。 
<BR>________________________________________ <BR>第一，谈谈final, finally, 
finalize的区别。 
<BR>final?修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 
abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载 
<BR>finally?再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 
finally 块（如果有的话）。 <BR>finalize?方法名。Java 技术允许使用 finalize() 
方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 
类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 
方法是在垃圾收集器删除对象之前对这个对象调用的。 <BR><BR>第二，Anonymous Inner Class (匿名内部类) 
是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 
<BR>匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。 
<BR><BR>第三，Static Nested Class 和 Inner Class的不同，说得越多越好(面试题有的很笼统)。 <BR>Nested 
Class （一般是C++的说法），Inner Class 
(一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。具体可见http: 
//www.frontfree.net/articles/services/view.asp?id=704&amp;page=1 <BR>注： 
静态内部类（Inner Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象 
<BR><BR>第四，&amp;和&amp;&amp;的区别。 <BR>&amp;是位运算符。&amp;&amp;是布尔逻辑运算符。 
<BR><BR>第五，HashMap和Hashtable的区别。 <BR>都属于Map接口的类，实现了将惟一键映射到特定的值上。 <BR>HashMap 
类没有分类或者排序。它允许一个 null 键和多个 null 值。 <BR>Hashtable 类似于 HashMap，但是不允许 null 键和 null 
值。它也比 HashMap 慢，因为它是同步的。 <BR><BR>第六，Collection 和 Collections的区别。 
<BR>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。 
<BR>Collection是个java.util下的接口，它是各种集合结构的父接口。 <BR><BR><BR>第七，什么时候用assert。 
<BR>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 
AssertionError。它用于调试目的： <BR>assert(a &gt; 0); // throws an AssertionError if a 
&lt;= 0 <BR>断言可以有两种形式： <BR>assert Expression1 ; <BR>assert Expression1 : 
Expression2 ; <BR>Expression1 应该总是产生一个布尔值。 <BR>Expression2 
可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。 <BR>断言在默认情况下是禁用的。要在编译时启用断言，需要使用 
source 1.4 标记： <BR>javac -source 1.4 Test.java <BR>要在运行时启用断言，可使用 
-enableassertions 或者 -ea 标记。 <BR>要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。 
<BR>要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。 
<BR>可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因 
为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改 变程序的状态。 
<BR><BR><BR>第八，GC是什么? 为什么要有GC? (基础)。 <BR>GC是垃圾收集器。Java 
程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： <BR>System.gc() 
<BR>Runtime.getRuntime().gc() <BR><BR>第九，String s = new 
String("xyz");创建了几个String Object? <BR>两个对象，一个是“xyx”,一个是指向“xyx”的引用对象s。 
<BR><BR>第十，Math.round(11.5)等於多少? Math.round(-11.5)等於多少? 
<BR>Math.round(11.5)返回（long）12，Math.round(-11.5)返回（long）-11; <BR><BR>第十一，short 
s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? <BR>short s1 = 1; s1 = s1 
+ 1;有错，s1是short型，s1+1是int型,不能显式转化为short型。可修改为s1 =(short)(s1 + 1) 。short s1 = 1; 
s1 += 1正确。 <BR><BR>第十二，sleep() 和 wait() 有什么区别? 搞线程的最爱 
<BR>sleep()方法是使线程停止一段时间的方法。在sleep 
时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非(a)“醒来”的线程具有更高的优先级 
<BR>(b)正在运行的线程因为其它原因而阻塞。 <BR>wait()是线程交互时，如果线程对一个同步对象x 
发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。 <BR><BR><BR><BR>第十三，Java有没有goto? 
<BR>Goto?java中的保留字，现在没有在java中使用。 <BR><BR>第十四，数组有没有length()这个方法? 
String有没有length()这个方法？ <BR>数组没有length()这个方法，有length的属性。 
<BR>String有有length()这个方法。 
<BR><BR>第十五，Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 
<BR>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一 
种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 
(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方 
法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 
<BR><BR>第十六，Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? 
<BR>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。 
<BR>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 
<BR><BR>第十七，给我一个你最常见到的runtime exception。 <BR>ArithmeticException, 
ArrayStoreException, BufferOverflowException, BufferUnderflowException, 
CannotRedoException, CannotUndoException, ClassCastException, CMMException, 
ConcurrentModificationException, DOMException, EmptyStackException, 
IllegalArgumentException, IllegalMonitorStateException, 
IllegalPathStateException, IllegalStateException, <BR>ImagingOpException, 
IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, 
NoSuchElementException, NullPointerException, ProfileDataException, 
ProviderException, RasterFormatException, SecurityException, SystemException, 
UndeclaredThrowableException, UnmodifiableSetException, 
UnsupportedOperationException <BR><BR>第十八，error和exception有什么区别? <BR>error 
表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 <BR>exception 
表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 <BR><BR><BR>第十九，List, Set, 
Map是否继承自Collection接口? <BR>List，Set是 <BR><BR>Map不是 <BR><BR>第二十，abstract 
class和interface有什么区别? <BR>声明方法的存在而不去实现它的类被叫做抽象类（abstract 
class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 
类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 
类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 
<BR>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的， 
没有一个有程序体。接口只可以定义static 
final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 
然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 
接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 
<BR><BR>第二十一，abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 
<BR>都不能 <BR><BR>第二十二，接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete 
class)? <BR>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。 
<BR><BR>第二十三，启动一个线程是用run()还是start()? 
<BR>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
<BR><BR><BR><BR>第二十四，构造器Constructor是否可被override? 
<BR>构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。 
<BR><BR>第二十五，是否可以继承String类? <BR>String类是final类故不可以继承。 
<BR><BR>第二十六，当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 
<BR>不能，一个对象的一个synchronized方法只能由一个线程访问。 <BR><BR>第二十七，try 
{}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? 
<BR>会执行，在return前执行。 <BR><BR><BR>第二十八，编程题: 用最有效率的方法算出2乘以8等於几? 
<BR>有C背景的程序员特别喜欢问这种问题。 <BR><BR>2 &lt;&lt; 3 <BR><BR>第二十九，两个对象值相同(x.equals(y) == 
true)，但却可有不同的hash code，这句话对不对? <BR>不对，有相同的hash code。 
<BR><BR>第三十，当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 
<BR>是值传递。Java 
编程语言只由值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 
<BR><BR><BR>第三十一，swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上? 
<BR>switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 
或者 byte。long,string 都不能作用于swtich。 <BR><BR>第三十二，编程题: 写一个Singleton出来。 
<BR>Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 <BR>一般Singleton模式通常有几种种形式: 
<BR>第一种形式: 
定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 
<BR>public class Singleton { <BR>　　private Singleton(){} 
<BR>　　//在自己内部定义自己一个实例，是不是很奇怪？ <BR>　　//注意这是private 只供内部调用 <BR>　　private static 
Singleton instance = new Singleton(); <BR>　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 
<BR>　　public static Singleton getInstance() { <BR>　　　　return instance; 　　 <BR>　　 
} <BR>} <BR>第二种形式: <BR>public class Singleton { <BR>　　private static Singleton 
instance = null; <BR>　　public static synchronized Singleton getInstance() { 
<BR>　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　 <BR>　　//使用时生成实例，提高了效率！ <BR>　　if 
(instance==null) <BR>　　　　instance＝new Singleton(); <BR>return instance; 　　} 
<BR>} <BR>其他形式: <BR>定义一个类，它的构造函数为private的，所有方法为static的。 <BR>一般认为第一种形式要更加安全些 
<BR>________________________________________ <BR>----&nbsp; Java面试题和答案&nbsp; 
(http://www.bioon.net/dispbbs.asp?boardid=169&amp;id=108010) 
<BR>________________________________________ <BR>--&nbsp; 作者：jiajia1983 
<BR>--&nbsp; 发布时间：2005-3-9 17:29:00 <BR><BR>--&nbsp; Java面试题和答案 <BR>JAVA相关基础知识 
<BR>1、面向对象的特征有哪些方面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>1.抽象： 
<BR>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 
<BR>2.继承： <BR>继 
承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继 
承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增 
加新的方法使之更适合特殊的需要。 <BR>3.封装： 
<BR>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 
<BR>4.&nbsp; 多态性： 
<BR>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 
<BR>2、String是最基本的数据类型吗? 
<BR>基本数据类型包括byte、int、char、long、float、double、boolean和short。 
<BR>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 
<BR>3、int&nbsp; 和&nbsp; Integer&nbsp; 有什么区别 <BR>Java&nbsp; 
提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。 
<BR>原始类型 封装类 <BR>boolean Boolean <BR>char Character <BR>byte Byte <BR>short 
Short <BR>int Integer <BR>long Long <BR>float Float <BR>double Double <BR>引 
用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数 
据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为&nbsp; null，而原始类型实例变量的缺省值与它们的 
类型有关。 <BR>4、String&nbsp; 和StringBuffer的区别 <BR>JAVA平台提供了两个类：String和StringBuffer， 
它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进 
行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。 
<BR>5、运行时异常与一般异常有何异同？ 
<BR>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 
<BR>6、说出Servlet的生命周期，并说出Servlet和CGI的区别。 
<BR>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。 
<BR>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 
<BR>7、说出ArrayList,Vector,&nbsp; LinkedList的存储性能和特性 <BR>ArrayList 
和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元 
素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差， 
而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 
<BR>8、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EJB包括Session&nbsp; Bean、Entity&nbsp; 
Bean、Message&nbsp; Driven&nbsp; Bean，基于JNDI、RMI、JAT等技术实现。 
<BR>SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。 
<BR>对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。 
<BR>对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。 
<BR>Session&nbsp; Bean&nbsp;&nbsp; 还可以再细分为&nbsp; Stateful&nbsp; Session&nbsp; 
Bean&nbsp; 与&nbsp; Stateless&nbsp; Session&nbsp; Bean&nbsp; ，这两种的&nbsp;&nbsp; 
Session&nbsp; Bean都可以将系统逻辑放在&nbsp; method之中执行，不同的是&nbsp; Stateful&nbsp; 
Session&nbsp; Bean&nbsp; 可以记 录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的&nbsp; Stateful&nbsp; 
Session&nbsp; Bean&nbsp; 的实体。 Stateless&nbsp; Session&nbsp; Bean&nbsp; 
虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫&nbsp;&nbsp; Stateless&nbsp; Session&nbsp; 
Bean&nbsp; 的时候，EJB&nbsp; Container&nbsp; 并不会找寻特定的&nbsp;&nbsp; Stateless&nbsp; 
Session&nbsp; Bean&nbsp; 的实体来执行这个&nbsp; method。换言之，很可能数个使用者在执行某个&nbsp;&nbsp; 
Stateless&nbsp; Session&nbsp; Bean&nbsp; 的&nbsp; methods&nbsp; 时，会是同一个&nbsp; 
Bean&nbsp; 的&nbsp; Instance&nbsp; 在执行。 从内存方面来看，&nbsp; Stateful&nbsp; 
Session&nbsp; Bean&nbsp; 与&nbsp; Stateless&nbsp; Session&nbsp; Bean&nbsp; 
比较，&nbsp;&nbsp; Stateful&nbsp; Session&nbsp; Bean&nbsp; 会消耗&nbsp; J2EE&nbsp; 
Server&nbsp; 较多的内存，然而&nbsp;&nbsp; Stateful&nbsp; Session&nbsp; Bean&nbsp; 
的优势却在于他可以维持使用者的状态。 <BR>9、Collection&nbsp; 和&nbsp; Collections的区别。&nbsp; 
<BR>　　Collection是集合类的上级接口，继承与他的接口主要有Set&nbsp; 和List. 
<BR>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 
<BR>10、&amp;和&amp;&amp;的区别。&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。 
<BR>11、HashMap和Hashtable的区别。&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 
<BR>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
<BR>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。&nbsp; 
<BR>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map&nbsp; interface的一个实现。 
<BR>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap&nbsp; 
就必须为之提供外同步。&nbsp; <BR>Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 
<BR>12、final,&nbsp; finally,&nbsp; finalize的区别。&nbsp; <BR>　　final&nbsp; 
用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 <BR>finally是异常处理语句结构的一部分，表示总是执行。 
<BR>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 
<BR>13、sleep()&nbsp; 和&nbsp; wait()&nbsp; 有什么区别?&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 
<BR>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 
<BR>14、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? <BR>方 
法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重 
载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写&nbsp;&nbsp; 
(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方 
法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 
<BR>15、error和exception有什么区别? <BR>error&nbsp; 
表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception&nbsp; 
表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。&nbsp; <BR>16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 
<BR>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 
<BR>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 
<BR>17、abstract&nbsp; class和interface有什么区别? <BR>声 
明方法的存在而不去实现它的类被叫做抽象类（abstract&nbsp; class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类 
中实现该类的情况。不能创建abstract&nbsp; 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函 
数或抽象静态方法。Abstract&nbsp; 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为 
的其它类可以在类中实现这些方法。 <BR>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获 
得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static&nbsp; final成员变量。接口的实现与子类相似，除了该实现类不能从接口 
定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有 
抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof&nbsp; 运算符可以用来 
决定某对象的类是否实现了接口。 <BR>18、heap和stack有什么区别。 
<BR>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。 <BR>堆是栈的一个组成元素 
<BR>19、forward&nbsp; 和redirect的区别 
<BR>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。 
<BR>20、EJB与JAVA&nbsp; BEAN的区别？ <BR>Java&nbsp; Bean&nbsp;&nbsp; 
是可复用的组件，对Java&nbsp; Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java&nbsp; 
Bean 是被容器所创建（如Tomcat）的，所以Java&nbsp; Bean应具有一个无参的构造器，另外，通常Java&nbsp; Bean还要实现 
Serializable接口用于实现Bean的持久性。Java&nbsp; Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访 
问的。Enterprise&nbsp; Java&nbsp; Bean&nbsp; 
相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可 
以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组 
件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 <BR>21、Static&nbsp; 
Nested&nbsp; Class&nbsp; 和&nbsp; Inner&nbsp; Class的不同。&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Static&nbsp; Nested&nbsp; 
Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 
<BR>22、JSP中动态INCLUDE与静态INCLUDE的区别？ <BR>动态INCLUDE用jsp:include动作实现&nbsp; 
&lt;jsp:include&nbsp; page="included.jsp"&nbsp; flush="true"&nbsp; 
/&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。 
<BR>静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面&lt;%@&nbsp; include&nbsp; 
file="included.htm"&nbsp; %&gt;&nbsp; <BR>23、什么时候用assert。&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它 
对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状 
态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高 
性能，在软件发布后，assertion检查通常是关闭的。 <BR>24、GC是什么?&nbsp; 为什么要有GC?&nbsp; <BR>　 
　GC是垃圾收集的意思（Gabage&nbsp; Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不 
稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。&nbsp;&nbsp; 
<BR>25、short&nbsp; s1&nbsp; =&nbsp; 1;&nbsp; s1&nbsp; =&nbsp; s1&nbsp; +&nbsp; 
1;有什么错?&nbsp; short&nbsp; s1&nbsp; =&nbsp; 1;&nbsp; s1&nbsp; +=&nbsp; 
1;有什么错?&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp; s1&nbsp; 
=&nbsp; 1;&nbsp; s1&nbsp; =&nbsp; s1&nbsp; +&nbsp; 1;&nbsp; 
（s1+1运算结果是int型，需要强制转换类型） <BR>short&nbsp; s1&nbsp; =&nbsp; 1;&nbsp; s1&nbsp; 
+=&nbsp; 1;（可以正确编译） <BR>26、Math.round(11.5)等於多少?&nbsp; 
Math.round(-11.5)等於多少?&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Math.round(11.5)==12 <BR>Math.round(-11.5)==-11 
<BR>round方法返回与参数最接近的长整数，参数加1/2后求其floor. <BR>27、String&nbsp; s&nbsp; =&nbsp; 
new&nbsp; String("xyz");创建了几个String&nbsp; Object?&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两个 
<BR>28、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 
<BR>以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 <BR>public&nbsp; class&nbsp; ThreadTest1{ 
<BR>&nbsp;&nbsp; private&nbsp; int&nbsp; j; <BR>&nbsp;&nbsp; public&nbsp; 
static&nbsp; void&nbsp; main(String&nbsp; args[]){ <BR>ThreadTest1&nbsp; 
tt=new&nbsp; ThreadTest1(); <BR>Inc&nbsp; inc=tt.new&nbsp; Inc(); <BR>Dec&nbsp; 
dec=tt.new&nbsp; Dec(); <BR>for(int&nbsp; i=0;i&lt;2;i++){ <BR>Thread&nbsp; 
t=new&nbsp; Thread(inc); <BR>t.start(); <BR>t=new&nbsp; Thread(dec); 
<BR>t.start(); <BR>} <BR>} <BR>&nbsp;&nbsp; private&nbsp; synchronized&nbsp; 
void&nbsp; inc(){ <BR>j++; 
<BR>System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
<BR>&nbsp;&nbsp; } <BR>&nbsp;&nbsp; private&nbsp; synchronized&nbsp; void&nbsp; 
dec(){ <BR>j--; 
<BR>System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
<BR>&nbsp;&nbsp; } <BR>&nbsp;&nbsp; class&nbsp; Inc&nbsp; implements&nbsp; 
Runnable{ <BR>public&nbsp; void&nbsp; run(){ <BR>for(int&nbsp; 
i=0;i&lt;100;i++){ <BR>inc(); <BR>} <BR>} <BR>&nbsp;&nbsp; } <BR>&nbsp;&nbsp; 
class&nbsp; Dec&nbsp; implements&nbsp; Runnable{ <BR>public&nbsp; void&nbsp; 
run(){ <BR>for(int&nbsp; i=0;i&lt;100;i++){ <BR>dec(); <BR>} <BR>&nbsp; } 
<BR>&nbsp;&nbsp; } <BR>} <BR>29、Java有没有goto? <BR>java中的保留字，现在没有在java中使用。 
<BR>30、启动一个线程是用run()还是start()? 
<BR>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
<BR>31、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ <BR>SessionBean： 
Stateless&nbsp; Session&nbsp; Bean&nbsp; 
的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建 
一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful&nbsp; Session&nbsp; 
Bean&nbsp; 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用 Stateful&nbsp; 
Session&nbsp; Bean&nbsp; 的方法时容器会把调用分派到与此客户机相关联的Bean实例。 <BR>EntityBean： 
Entity&nbsp; Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity&nbsp; 
beans就一直存活。而不是按照应用程 序或者服务进程来说的。即使EJB容器崩溃了，Entity&nbsp; beans也是存活的。Entity&nbsp; 
Beans生命周期能够被容器或者&nbsp; Beans 自己管理。 
<BR>EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun&nbsp; 
Microsystems的Transaction&nbsp; Service（JTS）、Java&nbsp; Transaction&nbsp; 
API（JTA），开发组（X/Open）的XA接口。 <BR>32、应用服务器有那些？ <BR>BEA&nbsp; WebLogic&nbsp; 
Server，IBM&nbsp; WebSphere&nbsp; Application&nbsp; Server，Oracle9i&nbsp; 
Application&nbsp; Server，jBoss，Tomcat <BR>33、给我一个你最常见到的runtime&nbsp; exception。 
<BR>ArithmeticException,&nbsp; ArrayStoreException,&nbsp; 
BufferOverflowException,&nbsp; BufferUnderflowException,&nbsp; 
CannotRedoException,&nbsp; CannotUndoException,&nbsp; ClassCastException,&nbsp; 
CMMException,&nbsp; ConcurrentModificationException,&nbsp; DOMException,&nbsp; 
EmptyStackException,&nbsp; IllegalArgumentException,&nbsp; 
IllegalMonitorStateException,&nbsp; IllegalPathStateException,&nbsp; 
IllegalStateException,&nbsp; ImagingOpException,&nbsp; 
IndexOutOfBoundsException,&nbsp; MissingResourceException,&nbsp; 
NegativeArraySizeException,&nbsp; NoSuchElementException,&nbsp; 
NullPointerException,&nbsp; ProfileDataException,&nbsp; ProviderException,&nbsp; 
RasterFormatException,&nbsp; SecurityException,&nbsp; SystemException,&nbsp; 
UndeclaredThrowableException,&nbsp; UnmodifiableSetException,&nbsp; 
UnsupportedOperationException <BR>34、接口是否可继承接口?&nbsp; 
抽象类是否可实现(implements)接口?&nbsp; 抽象类是否可继承实体类(concrete&nbsp; class)? 
<BR>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。 
<BR>35、List,&nbsp; Set,&nbsp; Map是否继承自Collection接口? 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List，Set是，Map不是 
<BR>________________________________________ <BR>Java常见面试题集- - 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>Java基础方面: <BR>1、作用域public,private,protected,以及不写时的区别 <BR>答：区别如下： <BR>作用域 当前类 
同一package 子孙类 其他package <BR>public √ √ √ √ <BR>protected √ √ √ × <BR>friendly √ 
√ × × <BR>private √ × × × <BR>不写时默认为friendly 
<BR>2、ArrayList和Vector的区别,HashMap和Hashtable的区别 <BR>答：就ArrayList与Vector主要从二方面来说. 
<BR>一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 
<BR>二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 
<BR>就HashMap与HashTable主要从三方面来说。 
<BR>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 
<BR>二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 
<BR>三.值：只有HashMap可以让你将空值作为一个表的条目的key或value <BR>3、char型变量中能不能存贮一个中文汉字?为什么? 
<BR>答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的 
<BR>4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? <BR>答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
<BR>同步的实现方面有两种，分别是synchronized,wait与notify <BR>5、继承时候类的执行顺序问题,一般都是选择题,问你将会打印出什么? 
<BR>答:父类： <BR>package test; <BR>public class FatherClass <BR>{ <BR>public 
FatherClass() <BR>{ <BR>System.out.println("FatherClass Create"); <BR>} <BR>} 
<BR>子类: <BR>package test; <BR>import test.FatherClass; <BR>public class 
ChildClass extends FatherClass <BR>{ <BR>public ChildClass() <BR>{ 
<BR>System.out.println("ChildClass Create"); <BR>} <BR>public static void 
main(String[] args) <BR>{ <BR>FatherClass fc = new FatherClass(); <BR>ChildClass 
cc = new ChildClass(); <BR>} <BR>} <BR>输出结果： <BR>C:&gt;java test.ChildClass 
<BR>FatherClass Create <BR>FatherClass Create <BR>ChildClass Create 
<BR>6、内部类的实现方式? <BR>答：示例代码如下： <BR>package test; <BR>public class OuterClass 
<BR>{ <BR>private class InterClass <BR>{ <BR>public InterClass() <BR>{ 
<BR>System.out.println("InterClass Create"); <BR>} <BR>} <BR>public OuterClass() 
<BR>{ <BR>InterClass ic = new InterClass(); <BR>System.out.println("OuterClass 
Create"); <BR>} <BR>public static void main(String[] args) <BR>{ <BR>OuterClass 
oc = new OuterClass(); <BR>} <BR>} <BR>输出结果: <BR>C:&gt;java test/OuterClass 
<BR>InterClass Create <BR>OuterClass Create <BR>再一个例题： <BR>public class 
OuterClass { <BR>private double d1 = 1.0; <BR>//insert code here <BR>} <BR>You 
need to insert an inner class declaration at line 3. Which two inner class 
declarations are <BR>valid?(Choose two.) <BR>A. class InnerOne{ <BR>public 
static double methoda() {return d1;} <BR>} <BR>B. public class InnerOne{ 
<BR>static double methoda() {return d1;} <BR>} <BR>C. private class InnerOne{ 
<BR>double methoda() {return d1;} <BR>} <BR>D. static class InnerOne{ 
<BR>protected double methoda() {return d1;} <BR>} <BR>E. abstract class 
InnerOne{ <BR>public abstract double methoda(); <BR>} <BR>说明如下： 
<BR>一.静态内部类可以有静态成员，而非静态内部类则不能有静态成员。 故 A、B 错 
<BR>二.静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量；return d1 出错。 <BR>故 D 错 
<BR>三.非静态内部类的非静态成员可以访问外部类的非静态变量。 故 C 正确 <BR>四.答案为C、E <BR>7、垃圾回收机制,如何优化程序? 
<BR>希望大家补上，谢谢 <BR>8、float型float f=3.4是否正确? <BR>答:不正确。精度不准确,应该用强制类型转换，如下所示：float 
f=(float)3.4 <BR>9、介绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)? <BR>答：Collection 
FrameWork如下： <BR>Collection <BR>├List <BR>│├LinkedList <BR>│├ArrayList 
<BR>│└Vector <BR>│　└Stack <BR>└Set <BR>Map <BR>├Hashtable <BR>├HashMap 
<BR>└WeakHashMap 
<BR>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements） 
<BR>Map提供key到value的映射 <BR>10、Java中异常处理机制，事件机制？ <BR>11、JAVA中的多形与继承？ <BR>希望大家补上，谢谢 
<BR>12、抽象类与接口？ <BR>答：抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。 
<BR>13、Java 的通信编程，编程题(或问答)，用JAVA SOCKET编程，读服务器几个字符，再写入本地显示？ <BR>答:Server端程序: 
<BR>package test; <BR>import java.net.*; <BR>import java.io.*; <BR>public class 
Server <BR>{ <BR>private ServerSocket ss; <BR>private Socket socket; <BR>private 
BufferedReader in; <BR>private PrintWriter out; <BR>public Server() <BR>{ 
<BR>try <BR>{ <BR>ss=new ServerSocket(10000); <BR>while(true) <BR>{ <BR>socket = 
ss.accept(); <BR>String RemoteIP = socket.getInetAddress().getHostAddress(); 
<BR>String RemotePort = ":"+socket.getLocalPort(); <BR>System.out.println("A 
client come in!IP:"+RemoteIP+RemotePort); <BR>in = new BufferedReader(new 
<BR>InputStreamReader(socket.getInputStream())); <BR>String line = 
in.readLine(); <BR>System.out.println("Cleint send is :" + line); <BR>out = new 
PrintWriter(socket.getOutputStream(),true); <BR>out.println("Your Message 
Received!"); <BR>out.close(); <BR>in.close(); <BR>socket.close(); <BR>} 
<BR>}catch (IOException e) <BR>{ <BR>out.println("wrong"); <BR>} <BR>} 
<BR>public static void main(String[] args) <BR>{ <BR>new Server(); <BR>} <BR>}; 
<BR>Client端程序: <BR>package test; <BR>import java.io.*; <BR>import java.net.*; 
<BR>public class Client <BR>{ <BR>Socket socket; <BR>BufferedReader in; 
<BR>PrintWriter out; <BR>public Client() <BR>{ <BR>try <BR>{ 
<BR>System.out.println("Try to Connect to 127.0.0.1:10000"); <BR>socket = new 
Socket("127.0.0.1",10000); <BR>System.out.println("The Server Connected!"); 
<BR>System.out.println("Please enter some Character:"); <BR>BufferedReader line 
= new BufferedReader(new <BR>InputStreamReader(System.in)); <BR>out = new 
PrintWriter(socket.getOutputStream(),true); <BR>out.println(line.readLine()); 
<BR>in = new BufferedReader(new InputStreamReader(socket.getInputStream())); 
<BR>System.out.println(in.readLine()); <BR>out.close(); <BR>in.close(); 
<BR>socket.close(); <BR>}catch(IOException e) <BR>{ <BR>out.println("Wrong"); 
<BR>} <BR>} <BR>public static void main(String[] args) <BR>{ <BR>new Client(); 
<BR>} <BR>}; <BR>14、用JAVA实现一种排序，JAVA类实现序列化的方法(二种)？ 
如在COLLECTION框架中，实现比较要实现什么样的接口？ <BR>答:用插入法进行排序代码如下 <BR>package test; <BR>import 
java.util.*; <BR>class InsertSort <BR>{ <BR>ArrayList al; <BR>public 
InsertSort(int num,int mod) <BR>{ <BR>al = new ArrayList(num); <BR>Random rand = 
new Random(); <BR>System.out.println("The ArrayList Sort Before:"); <BR>for (int 
i=0;i&lt;num ;i++ ) <BR>{ <BR>al.add(new Integer(Math.abs(rand.nextInt()) % mod 
+ 1)); <BR>System.out.println("al["+i+"]="+al.get(i)); <BR>} <BR>} <BR>public 
void SortIt() <BR>{ <BR>Integer tempInt; <BR>int MaxSize=1; <BR>for(int 
i=1;i&lt;al.size();i++) <BR>{ <BR>tempInt = (Integer)al.remove(i); 
<BR>if(tempInt.intValue()&gt;=((Integer)al.get(MaxSize-1)).intValue()) <BR>{ 
<BR>al.add(MaxSize,tempInt); <BR>MaxSize++; 
<BR>System.out.println(al.toString()); <BR>} else { <BR>for (int 
j=0;j&lt;MaxSize ;j++ ) <BR>{ <BR>if 
<BR>(((Integer)al.get(j)).intValue()&gt;=tempInt.intValue()) <BR>{ 
<BR>al.add(j,tempInt); <BR>MaxSize++; <BR>System.out.println(al.toString()); 
<BR>break; <BR>} <BR>} <BR>} <BR>} <BR>System.out.println("The ArrayList Sort 
After:"); <BR>for(int i=0;i&lt;al.size();i++) <BR>{ 
<BR>System.out.println("al["+i+"]="+al.get(i)); <BR>} <BR>} <BR>public static 
void main(String[] args) <BR>{ <BR>InsertSort is = new InsertSort(10,100); 
<BR>is.SortIt(); <BR>} <BR>} <BR>JAVA类实现序例化的方法是实现java.io.Serializable接口 
<BR>Collection框架中实现比较要实现Comparable 接口和 Comparator 接口 
<BR>15、编程：编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 
但是要保证汉字不被截半个，如"我ABC"4，应该截为"我AB"，输入"我ABC汉DEF"，6，应该输出为"我ABC"而不是"我ABC+汉的半个"。 
<BR>答：代码如下： <BR>package test; <BR>class SplitString <BR>{ <BR>String SplitStr; 
<BR>int SplitByte; <BR>public SplitString(String str,int bytes) <BR>{ 
<BR>SplitStr=str; <BR>SplitByte=bytes; <BR>System.out.println("The String 
is:′"+SplitStr+"′;SplitBytes="+SplitByte); <BR>} <BR>public void SplitIt() <BR>{ 
<BR>int loopCount; 
<BR><BR>loopCount=(SplitStr.length()%SplitByte==0)?(SplitStr.length()/SplitByte):(SplitStr.length()/Split 
<BR>Byte+1); <BR>System.out.println("Will Split into "+loopCount); <BR>for (int 
i=1;i&lt;=loopCount ;i++ ) <BR>{ <BR>if (i==loopCount){ 
<BR><BR>System.out.println(SplitStr.substring((i-1)*SplitByte,SplitStr.length())); 
<BR>} else { 
<BR><BR>System.out.println(SplitStr.substring((i-1)*SplitByte,(i*SplitByte))); 
<BR>} <BR>} <BR>} <BR>public static void main(String[] args) <BR>{ 
<BR>SplitString ss = new SplitString("test中dd文dsaf中男大3443n中国43中国人 
<BR>0ewldfls=103",4); <BR>ss.SplitIt(); <BR>} <BR>} <BR>16、JAVA多线程编程。 
用JAVA写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出。 <BR>希望大家补上，谢谢 
<BR>17、STRING与STRINGBUFFER的区别。 
<BR>答：STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法 
<BR>Jsp方面 <BR>1、jsp有哪些内置对象?作用分别是什么? <BR>答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： 
<BR>　request 用户端请求，此请求会包含来自GET/POST请求的参数 <BR>response 网页传回用户端的回应 <BR>pageContext 
网页的属性是在这里管理 <BR>session 与请求有关的会话期 <BR>application servlet 正在执行的内容 <BR>out 
用来传送回应的输出 <BR>config servlet的构架部件 <BR>page JSP网页本身 <BR>exception 针对错误网页，未捕捉的例外 
<BR>2、jsp有哪些动作?作用分别是什么? <BR>答:JSP共有以下6种基本动作 <BR>jsp:include：在页面被请求的时候引入一个文件。 
<BR>jsp:useBean：寻找或者实例化一个JavaBean。 <BR>jsp:setProperty：设置JavaBean的属性。 
<BR>jsp:getProperty：输出某个JavaBean的属性。 <BR>jsp:forward：把请求转到一个新的页面。 
<BR>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记 <BR>3、JSP中动态INCLUDE与静态INCLUDE的区别？ 
<BR>答：动态INCLUDE用jsp:include动作实现 <BR>&lt;jsp:include page="included.jsp" 
flush="true" /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 
<BR>静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <BR>&lt;%@ include 
file="included.htm" %&gt; <BR>4、两种跳转方式分别是什么?有什么区别? <BR>答：有两种，分别为： 
<BR>&lt;jsp:include page="included.jsp" flush="true"&gt; <BR>&lt;jsp:forward 
page= "nextpage.jsp"/&gt; 
<BR>前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go 
to 语句。 <BR>Servlet方面 <BR>1、说一说Servlet的生命周期? 
<BR>答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 
<BR>2、Servlet版本间(忘了问的是哪两个版本了)的不同? <BR>希望大家补上，谢谢 <BR>3、JAVA SERVLET API中forward() 
与redirect()的区别？ 
<BR>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请 
求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也 
有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。 <BR>4、Servlet的基本架构 
<BR>public class ServletName extends HttpServlet { <BR>public void 
doPost(HttpServletRequest request, HttpServletResponse response) throws 
<BR>ServletException, IOException { <BR>} <BR>public void 
doGet(HttpServletRequest request, HttpServletResponse response) throws 
<BR>ServletException, IOException { <BR>} <BR>} <BR>Jdbc、Jdo方面 
<BR>1、可能会让你写一段Jdbc连Oracle的程序,并实现数据查询. <BR>答:程序如下： <BR>package hello.ant; 
<BR>import java.sql.*; <BR>public class jdbc <BR>{ <BR>String 
dbUrl="jdbc:oracle:thin:@127.0.0.1:1521:orcl"; <BR>String theUser="admin"; 
<BR>String thePw="manager"; <BR>Connection c=null; <BR>Statement conn; 
<BR>ResultSet rs=null; <BR>public jdbc() <BR>{ <BR>try{ 
<BR>Class.forName("oracle.jdbc.driver.OracleDriver").newInstance(); <BR>c = 
DriverManager.getConnection(dbUrl,theUser,thePw); <BR>conn=c.createStatement(); 
<BR>}catch(Exception e){ <BR>e.printStackTrace(); <BR>} <BR>} <BR>public boolean 
executeUpdate(String sql) <BR>{ <BR>try <BR>{ <BR>conn.executeUpdate(sql); 
<BR>return true; <BR>} <BR>catch (SQLException e) <BR>{ <BR>e.printStackTrace(); 
<BR>return false; <BR>} <BR>} <BR>public ResultSet executeQuery(String sql) 
<BR>{ <BR>rs=null; <BR>try <BR>{ <BR>rs=conn.executeQuery(sql); <BR>} <BR>catch 
(SQLException e) <BR>{ <BR>e.printStackTrace(); <BR>} <BR>return rs; <BR>} 
<BR>public void close() <BR>{ <BR>try <BR>{ <BR>conn.close(); <BR>c.close(); 
<BR>} <BR>catch (Exception e) <BR>{ <BR>e.printStackTrace(); <BR>} <BR>} 
<BR>public static void main(String[] args) <BR>{ <BR>ResultSet rs; <BR>jdbc conn 
= new jdbc(); <BR>rs=conn.executeQuery("select * from test"); <BR>try{ <BR>while 
(rs.next()) <BR>{ <BR>System.out.println(rs.getString("id")); 
<BR>System.out.println(rs.getString("name")); <BR>} <BR>}catch(Exception e) 
<BR>{ <BR>e.printStackTrace(); <BR>} <BR>} <BR>} <BR>2、Class.forName的作用?为什么要用? 
<BR>答：调用该访问返回一个以字符串指定类名的类的对象。 <BR>3、Jdo是什么? <BR>答:JDO是Java对象持久化的新的规范，为java data 
object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额 
外的代码（如JDBC 
API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它 
可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对 
象数据库（ODBMS）等等，使得应用可移植性更强。 <BR>4、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法。 
<BR>答:一种分页方法 <BR>&lt;% <BR>int i=1; <BR>int numPages=14; <BR>String pages = 
request.getParameter("page") ; <BR>int currentPage = 1; 
<BR>currentPage=(pages==null)?(1):{Integer.parseInt(pages)} <BR>sql = "select 
count(*) from tables"; <BR>ResultSet rs = DBLink.executeQuery(sql) ; 
<BR>while(rs.next()) i = rs.getInt(1) ; <BR>int intPageCount=1; 
<BR>intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1); <BR>int nextPage ; 
<BR>int upPage; <BR>nextPage = currentPage+1; <BR>if (nextPage&gt;=intPageCount) 
nextPage=intPageCount; <BR>upPage = currentPage-1; <BR>if (upPage&lt;=1) 
upPage=1; <BR>rs.close(); <BR>sql="select * from tables"; 
<BR>rs=DBLink.executeQuery(sql); <BR>i=0; 
<BR>while((i&lt;numPages*(currentPage-1))&amp;&amp;rs.next()){i++;} <BR>%&gt; 
<BR>//输出内容 <BR>//输出翻页连接 
<BR>合计:&lt;%=currentPage%&gt;/&lt;%=intPageCount%&gt;&lt;a 
href="List.jsp?page=1"&gt;第一页&lt;/a&gt;&lt;a 
<BR>href="List.jsp?page=&lt;%=upPage%&gt;"&gt;上一页&lt;/a&gt; <BR>&lt;% 
<BR>for(int j=1;j&lt;=intPageCount;j++){ <BR>if(currentPage!=j){ <BR>%&gt; 
<BR>&lt;a href="list.jsp?page=&lt;%=j%&gt;"&gt;[&lt;%=j%&gt;]&lt;/a&gt; 
<BR>&lt;% <BR>}else{ <BR>out.println(j); <BR>} <BR>} <BR>%&gt; <BR>&lt;a 
href="List.jsp?page=&lt;%=nextPage%&gt;"&gt;下一页&lt;/a&gt;&lt;a 
href="List.jsp?page=&lt;%=intPageCount%&gt;"&gt;最后页 <BR>&lt;/a&gt; <BR><BR>Xml方面 
<BR>1、xml有哪些解析技术?区别是什么? <BR>答:有DOM,SAX,STAX等 
<BR>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整 
个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文 
件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺 序访问 
<BR>STAX:Streaming API for XML (StAX) <BR>2、你在项目中用到了xml技术的哪些方面?如何实现的? 
<BR>答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给 
接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件 中。 
<BR>3、用jdom解析xml文件时如何解决中文问题?如何解析? <BR>答:看如下代码,用编码方式加以解决 <BR>package test; 
<BR>import java.io.*; <BR>public class DOMTest <BR>{ <BR>private String inFile = 
"c:\people.xml"; <BR>private String outFile = "c:\people.xml"; <BR>public static 
void main(String args[]) <BR>{ <BR>new DOMTest(); <BR>} <BR>public DOMTest() 
<BR>{ <BR>try <BR>{ <BR>javax.xml.parsers.DocumentBuilder builder = 
<BR><BR>javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); 
<BR>org.w3c.dom.Document doc = builder.newDocument(); <BR>org.w3c.dom.Element 
root = doc.createElement("老师"); <BR>org.w3c.dom.Element wang = 
doc.createElement("王"); <BR>org.w3c.dom.Element liu = doc.createElement("刘"); 
<BR>wang.appendChild(doc.createTextNode("我是王老师")); <BR>root.appendChild(wang); 
<BR>doc.appendChild(root); <BR>javax.xml.transform.Transformer transformer = 
<BR>javax.xml.transform.TransformerFactory.newInstance().newTransformer(); 
<BR>transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, 
"gb2312"); 
<BR>transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, "yes"); 
<BR><BR>transformer.transform(new javax.xml.transform.dom.DOMSource(doc), 
<BR>new <BR>javax.xml.transform.stream.StreamResult(outFile)); <BR>} <BR>catch 
(Exception e) <BR>{ <BR>System.out.println (e.getMessage()); <BR>} <BR>} <BR>} 
<BR>4、编程用JAVA解析XML的方式. <BR>答:用SAX方式解析XML，XML文件如下： <BR>&lt;?xml version="1.0" 
encoding="gb2312"?&gt; <BR>&lt;person&gt; <BR>&lt;name&gt;王小明&lt;/name&gt; 
<BR>&lt;college&gt;信息学院&lt;/college&gt; 
<BR>&lt;telephone&gt;6258113&lt;/telephone&gt; 
<BR>&lt;notes&gt;男,1955年生,博士，95年调入海南大学&lt;/notes&gt; <BR>&lt;/person&gt; 
<BR>事件回调类SAXHandler.java <BR>import java.io.*; <BR>import java.util.Hashtable; 
<BR>import org.xml.sax.*; <BR>public class SAXHandler extends HandlerBase <BR>{ 
<BR>private Hashtable table = new Hashtable(); <BR>private String currentElement 
= null; <BR>private String currentValue = null; <BR>public void 
setTable(Hashtable table) <BR>{ <BR>this.table = table; <BR>} <BR>public 
Hashtable getTable() <BR>{ <BR>return table; <BR>} <BR>public void 
startElement(String tag, AttributeList attrs) <BR>throws SAXException <BR>{ 
<BR>currentElement = tag; <BR>} <BR>public void characters(char[] ch, int start, 
int length) <BR>throws SAXException <BR>{ <BR>currentValue = new String(ch, 
start, length); <BR>} <BR>public void endElement(String name) throws 
SAXException <BR>{ <BR>if (currentElement.equals(name)) 
<BR>table.put(currentElement, currentValue); <BR>} <BR>} 
<BR>JSP内容显示源码,SaxXml.jsp: <BR>&lt;HTML&gt; <BR>&lt;HEAD&gt; 
<BR>&lt;TITLE&gt;剖析XML文件people.xml&lt;/TITLE&gt; <BR>&lt;/HEAD&gt; 
<BR>&lt;BODY&gt; <BR>&lt;%@ page errorPage="ErrPage.jsp" 
<BR>contentType="text/html;charset=GB2312" %&gt; <BR>&lt;%@ page 
import="java.io.*" %&gt; <BR>&lt;%@ page import="java.util.Hashtable" %&gt; 
<BR>&lt;%@ page import="org.w3c.dom.*" %&gt; <BR>&lt;%@ page 
import="org.xml.sax.*" %&gt; <BR>&lt;%@ page 
import="javax.xml.parsers.SAXParserFactory" %&gt; <BR>&lt;%@ page 
import="javax.xml.parsers.SAXParser" %&gt; <BR>&lt;%@ page import="SAXHandler" 
%&gt; <BR>&lt;% <BR>File file = new File("c:\people.xml"); <BR>FileReader reader 
= new FileReader(file); <BR>Parser parser; <BR>SAXParserFactory spf = 
SAXParserFactory.newInstance(); <BR>SAXParser sp = spf.newSAXParser(); 
<BR>SAXHandler handler = new SAXHandler(); <BR>sp.parse(new InputSource(reader), 
handler); <BR>Hashtable hashTable = handler.getTable(); 
<BR>out.println("&lt;TABLE BORDER=2&gt;&lt;CAPTION&gt;教师信息表&lt;/CAPTION&gt;"); 
<BR>out.println("&lt;TR&gt;&lt;TD&gt;姓名&lt;/TD&gt;" + "&lt;TD&gt;" + 
<BR>(String)hashTable.get(new String("name")) + "&lt;/TD&gt;&lt;/TR&gt;"); 
<BR>out.println("&lt;TR&gt;&lt;TD&gt;学院&lt;/TD&gt;" + "&lt;TD&gt;" + 
<BR>(String)hashTable.get(new String("college"))+"&lt;/TD&gt;&lt;/TR&gt;"); 
<BR>out.println("&lt;TR&gt;&lt;TD&gt;电话&lt;/TD&gt;" + "&lt;TD&gt;" + 
<BR>(String)hashTable.get(new String("telephone")) + "&lt;/TD&gt;&lt;/TR&gt;"); 
<BR>out.println("&lt;TR&gt;&lt;TD&gt;备注&lt;/TD&gt;" + "&lt;TD&gt;" + 
<BR>(String)hashTable.get(new String("notes")) + "&lt;/TD&gt;&lt;/TR&gt;"); 
<BR>out.println("&lt;/TABLE&gt;"); <BR>%&gt; <BR>&lt;/BODY&gt; <BR>&lt;/HTML&gt; 
<BR>EJB方面 <BR>1、EJB2.0有哪些内容?分别用在什么场合? EJB2.0和EJB1.1的区别? 
<BR>答：规范内容包括Bean提供者，应用程序装配者，EJB容器，EJB配置工具，EJB服务提供者，系统管理员。这里面，EJB容器是EJB之所 
以能够运行的核心。EJB容器管理着EJB的创建，撤消，激活，去活，与数据库的连接等等重要的核心工作。JSP,Servlet,EJB,JNDI, 
JDBC,JMS..... <BR>2、EJB与JAVA BEAN的区别？ <BR>答:Java Bean 是可复用的组件，对Java 
Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat)的，所以Java 
Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java 
Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 
相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在 
诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理， 
EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 <BR>3、EJB的基本架构 <BR>答:一个EJB包括三个部分: <BR>Remote 
Interface 接口的代码 <BR>package Beans; <BR>import javax.ejb.EJBObject; <BR>import 
java.rmi.RemoteException; <BR>public interface Add extends EJBObject <BR>{ 
<BR>//some method declare <BR>} <BR>Home Interface 接口的代码 <BR>package Beans; 
<BR>import java.rmi.RemoteException; <BR>import jaax.ejb.CreateException; 
<BR>import javax.ejb.EJBHome; <BR>public interface AddHome extends EJBHome <BR>{ 
<BR>//some method declare <BR>} <BR>EJB类的代码 <BR>package Beans; <BR>import 
java.rmi.RemoteException; <BR>import javax.ejb.SessionBean; <BR>import 
javx.ejb.SessionContext; <BR>public class AddBean Implements SessionBean <BR>{ 
<BR>//some method declare <BR>} <BR>J2EE,MVC方面 <BR>1、MVC的各个部分都有那些技术来实现?如何实现? 
<BR>答:MVC是Model－View－Controller的简写。"Model" 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， 
"View" 是应用的表示面（由JSP页面产生），"Controller" 
是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 
<BR>2、应用服务器与WEB SERVER的区别？ <BR>希望大家补上，谢谢 <BR><BR>3、J2EE是什么？ 
<BR>答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese 
application 
model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn 
tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。 <BR>4、WEB 
SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 <BR>答：Web Service描述语言WSDL 
<BR>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。 </DIV>
<DIV class=blog_bottom>
<UL>
  <LI>10:38 </LI>
  <LI>浏览 (208) </LI>
  <LI><A href="http://bruce-peng.javaeye.com/blog/198149#comments">评论</A> (0) 
  </LI>
  <LI>分类: <A href="http://bruce-peng.javaeye.com/category/30629">java</A> </LI>
  <LI class=last><A class=more href="http://www.javaeye.com/wiki/topic/198149" 
  target=_blank>相关推荐</A> </LI></UL></DIV>
<DIV class=blog_comment>
<H5>评论</H5><A id=comments name=comments></A></DIV>
<DIV class=blog_comment>
<H5>发表评论</H5>
<FORM id=comment_form onsubmit="return false;" action=/blog/198149 
method=post><INPUT id=editor_bbcode_flag type=hidden> 
<DIV id=editor_main><TEXTAREA class="validate-richeditor bad-words min-length-5" id=editor_body style="WIDTH: 500px; HEIGHT: 350px" name=comment[body] rows=20 cols=40></TEXTAREA></DIV>
<SCRIPT type=text/javascript>
  var editor = new Control.TextArea.Editor("editor_body", "bbcode", false);
</SCRIPT>

<P style="PADDING-RIGHT: 30px; TEXT-ALIGN: right">您还没有登录，请<A 
href="http://bruce-peng.javaeye.com/login">登录</A>后发表评论 <INPUT class=submit id=submit_button type=submit value=提交 name=commit></P></FORM>
<SCRIPT type=text/javascript>
        new Validation("comment_form", {immediate: false, onFormValidate: function(result, form){
  
        if(confirm('您需要登录以后才能执行这个操作，现在要登录吗？')) window.location.href = '/login';
  
    }});
      </SCRIPT>
</DIV></DIV>
<SCRIPT type=text/javascript>
dp.SyntaxHighlighter.ClipboardSwf = '/javascripts/syntaxhighlighter/clipboard.swf';
dp.SyntaxHighlighter.HighlightAll('code', true, true);

fix_image_size($$('div.blog_content img'), 700);
function quote_comment(link) {
  quote_user = $(link).previous(0).innerHTML;
  quote_body = $(link).up().next().innerHTML.stripTags();
  editor.bbcode_editor.textarea.insertAfterSelection('[quote="'+quote_user+'"]\n' + quote_body + '\n[/quote]\n');
}
</SCRIPT>
</DIV>
<DIV id=local>
<DIV class=local_top></DIV>
<DIV id=blog_owner>
<DIV id=blog_owner_logo><A href="http://bruce-peng.javaeye.com/"><IMG 
title="bruce.peng的博客: bruce.peng" alt=用户头像 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/73117ea0-d381-38b3-bf96-e32e1960581a.png"></A></DIV>
<DIV id=blog_owner_name>bruce.peng</DIV></DIV>
<DIV id=blog_actions>
<UL>
  <LI>浏览: 4890 次 
  <LI>性别: <IMG title=男 alt=Icon_minigender_1 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/icon_minigender_1.gif"> 

  <LI>来自: 深圳 
  <LI><IMG 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/offline.gif"> 
  <LI><A href="http://bruce-peng.javaeye.com/blog/profile">详细资料</A> </LI></UL>
<H5>搜索本博客</H5>
<FORM action=/blog/search method=get><INPUT class=text id=query 
style="MARGIN-LEFT: 10px; WIDTH: 110px" name=query> <INPUT class=submit type=submit value=搜索> </FORM></DIV>
<DIV id=blog_menu>
<H5>博客分类</H5>
<UL>
  <LI><A href="http://bruce-peng.javaeye.com/">全部博客 (25)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30628">reproduced (2)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30629">java (1)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30630">flex (11)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30631">DB (2)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30632">Spring (2)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30633">Hibernate (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30634">template (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/30635">others (1)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/32809">design (4)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/40124">tool software 
  (1)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42055">Maven Ant (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42056">Bugzilla (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42059">JIRA (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42060">SWT/JFace (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42061">Eclipse (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42062">Aptana (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42063">RCP (0)</A> 
  <LI><A href="http://bruce-peng.javaeye.com/category/42064">SmartClient (0)</A> 
  </LI></UL></DIV>
<DIV id=blog_album>
<H5>我的相册</H5>
<DIV class=picture_thumb style="FLOAT: none">
<DIV><SPAN class=thumb_box><A href="http://bruce-peng.javaeye.com/album"><IMG 
alt=02dd3ef6-0bee-3098-8b4e-c0cde7d2ea1c-thumb 
src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/02dd3ef6-0bee-3098-8b4e-c0cde7d2ea1c-thumb.jpg"></A></SPAN></DIV><SPAN>公司员工<BR><A 
href="http://bruce-peng.javaeye.com/album">共 1 张</A></SPAN> </DIV></DIV>
<DIV id=blog_others>
<H5>其他分类</H5>
<UL>
  <LI><A href="http://bruce-peng.javaeye.com/blog/favorite">我的收藏</A> (87) 
  <LI><A href="http://bruce-peng.javaeye.com/blog/forum">我的论坛帖子</A> (26) 
  <LI><A href="http://bruce-peng.javaeye.com/blog/article">我的精华良好贴</A> (0) 
</LI></UL></DIV>
<DIV id=recent_groups>
<H5>最近加入圈子</H5>
<UL>
  <LI><A href="http://dusk.group.javaeye.com/">珠海之夜</A> 
  <LI><A href="http://dianzishu.group.javaeye.com/">共享电子书</A> 
  <LI><A href="http://database.group.javaeye.com/">Database圈子</A> 
  <LI><A href="http://turingbook.group.javaeye.com/">图灵俱乐部</A> 
  <LI><A href="http://eclipsercpforum.group.javaeye.com/">Eclipse 
  PlugIns&amp;RCP&amp;OSGI</A> </LI></UL></DIV>
<DIV id=user_links>
<H5>链接</H5>
<UL>
  <LI><A href="http://www.adobe.com/devnet/flex/articles/fullstack_pt1.html" 
  target=_blank>flex spring </A>
  <LI><A href="http://www.adobe.com/devnet/flex/articles/unit_testing.html" 
  target=_blank>flex test</A> 
  <LI><A 
  href="http://snowyrock.spaces.live.com/Blog/cns!B8CBEB7169880B1D!577.entry" 
  target=_blank>flex 框架</A> 
  <LI><A href="http://bbs.ad0.cn/viewthread.php?tid=313&amp;extra=page%3D1" 
  target=_blank>Flex或Flash的跨域访问解决方案</A> 
  <LI><A href="http://www.jzxue.com/Html/daima/092400340393936.html" 
  target=_blank>javascript</A> 
  <LI><A href="http://www.flex-flex.net/" target=_blank>flex 博客</A> 
  <LI><A href="http://www.bigbug.us/wordpress/" target=_blank>SWZ文件</A> 
  <LI><A href="http://www.blogjava.net/cpenet/archive/2006/07/04/56539.html" 
  target=_blank>SWT </A>
  <LI><A href="http://l2fprod.com/common/" target=_blank>SWT</A> 
  <LI><A href="http://www.eclipseworld.org/bbs/read.php?tid=172" 
  target=_blank>SWT 论坛</A> 
  <LI><A 
  href="http://blogzb.spaces.live.com/?_c11_BlogPart_BlogPart=blogview&amp;_c=BlogPart&amp;partqs=cat%3dxml%2b(%25e5%25b0%258f%25e6%25af%259b%25e9%25a9%25b4%25e5%2584%25bf)" 
  target=_blank>javaScript 和xml</A> 
  <LI><A href="http://www.nshen.net/blog/article.asp?id=509" target=_blank>Flash 
  Media Server 入门教程</A> 
  <LI><A href="http://tomcat.jaxwiki.org/index.html" target=_blank>Apache Tomcat 
  5.5 Servlet/JSP 容器</A> 
  <LI><A href="http://www.eclipseworld.org/bbs/read-cec-tid-16160-fpage-5.html" 
  target=_blank>教你一招克死所有病毒</A> </LI></UL></DIV>
<DIV id=month_blogs>
<H5>存档</H5>
<UL>
  <LI><A href="http://bruce-peng.javaeye.com/blog/monthblog/2008-09">2008-09</A> 
  (1) 
  <LI><A href="http://bruce-peng.javaeye.com/blog/monthblog/2008-08">2008-08</A> 
  (2) 
  <LI><A href="http://bruce-peng.javaeye.com/blog/monthblog/2008-07">2008-07</A> 
  (1) 
  <LI><A href="http://bruce-peng.javaeye.com/blog/monthblog_more">更多存档...</A> 
  </LI></UL></DIV>
<DIV id=recent_comments>
<H5>最新评论</H5>
<UL>
  <LI><A title=只要是java程序员都会喜欢flex的. 
  href="http://bruce-peng.javaeye.com/blog/199002#comments">只要是java程序员都会喜欢 
  ...</A><BR>对,我也很喜欢,想找空学习学习.<BR>-- by <A href="http://chenlb.javaeye.com/" 
  target=_blank>chenlb</A> 
  <LI><A title=只要是java程序员都会喜欢flex的. 
  href="http://bruce-peng.javaeye.com/blog/199002#comments">只要是java程序员都会喜欢 
  ...</A><BR>每个子页面都定义&lt;mx:state&gt; 吗？我在父类有一个State的属性， ...<BR>-- by <A 
  href="http://bruce-peng.javaeye.com/" target=_blank>bruce.peng</A> 
  <LI><A title=只要是java程序员都会喜欢flex的. 
  href="http://bruce-peng.javaeye.com/blog/199002#comments">只要是java程序员都会喜欢 
  ...</A><BR>呵呵，那们兄台用牛刀杀鸡了。其实你可以定义&lt;mx:state&gt;来改变页面的 ...<BR>-- by <A 
  href="http://cph8066.javaeye.com/" target=_blank>cph8066</A> 
  <LI><A title=收集的flex学习网站. 
  href="http://bruce-peng.javaeye.com/blog/199116#comments">收集的flex学习网站.</A><BR>不错<BR>-- 
  by <A href="http://hspeed.javaeye.com/" target=_blank>hspeed</A> 
  <LI><A title=只要是java程序员都会喜欢flex的. 
  href="http://bruce-peng.javaeye.com/blog/199002#comments">只要是java程序员都会喜欢 
  ...</A><BR>刚刚把我收集的flex学习网站放在上面了,有兴趣可以去看看。http://bru ...<BR>-- by <A 
  href="http://bruce-peng.javaeye.com/" target=_blank>bruce.peng</A> 
</LI></UL></DIV>
<DIV id=comments_top>
<H5>评论排行榜</H5>
<UL>
  <LI><A href="http://bruce-peng.javaeye.com/blog/195005">关于跳巢，请大家给点建议！</A> 
  <LI><A 
  href="http://bruce-peng.javaeye.com/blog/199002">只要是java程序员都会喜欢flex的.</A> 
  <LI><A href="http://bruce-peng.javaeye.com/blog/196998">设计模式－单例模式</A> 
  <LI><A href="http://bruce-peng.javaeye.com/blog/199116">收集的flex学习网站.</A> 
  <LI><A href="http://bruce-peng.javaeye.com/blog/198149">java 试题-- 
  为找工作作准备,呵呵！</A> </LI></UL></DIV>
<DIV id=rss>
<UL>
  <LI><A href="http://bruce-peng.javaeye.com/rss" target=_blank><IMG alt=Rss 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/rss.png"></A> 
  <LI><A 
  href="http://fusion.google.com/add?feedurl=http://bruce-peng.javaeye.com/rss" 
  target=_blank><IMG alt=Rss_google 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/rss_google.gif"></A> 

  <LI><A 
  href="http://www.zhuaxia.com/add_channel.php?url=http://bruce-peng.javaeye.com/rss" 
  target=_blank><IMG alt=Rss_zhuaxia 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/rss_zhuaxia.gif"></A> 

  <LI><A 
  href="http://www.xianguo.com/subscribe.php?url=http://bruce-peng.javaeye.com/rss" 
  target=_blank><IMG alt=Rss_xianguo 
  src="java 试题-- 为找工作作准备,呵呵！ - bruce_peng - JavaEye技术网站.files/rss_xianguo.jpg"></A> 

  <LI><A href="http://www.google.com/search?hl=zh-CN&amp;q=RSS">[什么是RSS?]</A> 
  </LI></UL></DIV>
<DIV class=local_bottom></DIV></DIV></DIV>
<DIV class=clearfix id=footer>
<DIV id=copyright>
<HR>
声明：JavaEye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。<BR>© 
2003-2008 JavaEye.com. All rights reserved. 上海炯耐计算机软件有限公司 [ 沪ICP备05023328号 ] 
</DIV></DIV></DIV>
<SCRIPT type=text/javascript>
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</SCRIPT>

<SCRIPT type=text/javascript>
var pageTracker = _gat._getTracker("UA-535605-1");
pageTracker._setDomainName("javaeye.com");
pageTracker._initData();
pageTracker._trackPageview();
</SCRIPT>
</BODY></HTML>
